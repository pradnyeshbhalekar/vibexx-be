from flask import Blueprint, request, session
from app.services.spotify_service import get_spotify_client
from app.services.reccobeats_service import get_audio_features
from app.services.mood_engine import rank_tracks_by_mood

playlist_routes = Blueprint("playlist_routes", __name__, url_prefix="/api/playlist")


@playlist_routes.route("/create", methods=["POST"])
def create_playlist():
    data = request.get_json() or {}
    mood = data.get("mood")
    limit = int(data.get("limit", 30))

    if not mood:
        return {"error": "Mood is required"}, 400

    sp = get_spotify_client()

    track_ids = session.get("selected_tracks")

    if not track_ids:
        selected_artists = session.get("selected_artists")

        if not selected_artists or len(selected_artists) != 5:
            return {"error": "Exactly 5 selected artists are required"}, 400

        track_map = {}

        for artist_id in selected_artists:
            results = sp.artist_top_tracks(artist_id)

            for track in results.get("tracks", []):
                tid = track.get("id")
                if tid:
                    track_map[tid] = tid

        track_ids = list(track_map.values())[:50]

        if not track_ids:
            return {"error": "No tracks found from selected artists"}, 400

        session["selected_tracks"] = track_ids

    audio_features = get_audio_features(track_ids)

    if not audio_features:
        return {"error": "No audio feature returned"}, 400

    fixed_features = []
    for i, f in enumerate(audio_features):
        if not isinstance(f, dict):
            continue

        tid = f.get("spotify_id") or f.get("id")

        if not tid and i < len(track_ids):
            tid = track_ids[i]

        f["id"] = tid
        fixed_features.append(f)

    if not fixed_features:
        return {"error": "Audio features invalid / empty"}, 400

    ranked_tracks = rank_tracks_by_mood(fixed_features, mood)

    if not ranked_tracks:
        return {"error": "Ranking failed / empty ranked list"}, 400

    top_tracks = []
    for t in ranked_tracks:
        if not isinstance(t, dict):
            continue
        if t.get("id"):
            top_tracks.append(t)
        if len(top_tracks) >= limit:
            break

    if not top_tracks:
        return {"error": "No tracks after ranking (missing track IDs)"}, 400

    track_ids_added = [t["id"] for t in top_tracks if t.get("id")]
    track_uris = [f"spotify:track:{tid}" for tid in track_ids_added]

    if not track_uris:
        return {"error": "No valid Spotify track URIs generated"}, 400

    try:
        user = sp.current_user()
    except Exception as e:
        return {"error": "Spotify not authenticated", "details": str(e)}, 401

    playlist = sp.user_playlist_create(
        user=user["id"],
        name=f"Vibexx â€¢ {mood.capitalize()}",
        public=False,
        description=f"Mood-based playlist generated by Vibexx ({mood})",
    )

    for i in range(0, len(track_uris), 100):
        sp.playlist_add_items(playlist["id"], track_uris[i : i + 100])

    spotify_tracks = sp.tracks(track_ids_added).get("tracks", [])

    track_meta_map = {}
    for tr in spotify_tracks:
        if not tr or not tr.get("id"):
            continue

        track_meta_map[tr["id"]] = {
            "id": tr["id"],
            "name": tr.get("name"),
            "artists": [a.get("name") for a in tr.get("artists", []) if a.get("name")],
            "preview_url": tr.get("preview_url"),
            "spotify_url": tr.get("external_urls", {}).get("spotify"),
            "image": (
                tr.get("album", {}).get("images", [{}])[0].get("url")
                if tr.get("album", {}).get("images")
                else None
            ),
            "album_name": tr.get("album", {}).get("name"),
        }

    tracks = []
    for t in top_tracks:
        tid = t.get("id")
        if not tid:
            continue

        meta = track_meta_map.get(tid, {"id": tid})

        tracks.append({
            **meta,
            "mood_score": t.get("mood_score"),
            "valence": t.get("valence"),
            "energy": t.get("energy"),
            "tempo": t.get("tempo"),
            "danceability": t.get("danceability"),
            "acousticness": t.get("acousticness"),
            "instrumentalness": t.get("instrumentalness"),
        })

    session.pop("selected_artists", None)
    session.pop("selected_tracks", None)

    return {
        "id": playlist["id"],
        "mood": mood,
        "track_count": len(track_uris),
        "playlist_url": playlist["external_urls"]["spotify"],
        "tracks": tracks,
    }
